Audit findings for secure-tunnel workspace
Generated: 2025-12-21

---
File: bench_models.py
Path: bench_models.py
Role: Lightweight stub providing a power prediction helper for automation.
Key symbols: calculate_predicted_flight_constraint(horizontal_mps, vertical_mps, weight_n)
Inputs: numeric speed and weight; Outputs: float power estimate (watts).
Observations: Simple, defensive conversion to float; returns 0.0 on parse error.
Issues/Risks: None significant. Function is intentionally approximate and safe.
Severity: Low
Suggestion: None — acceptable as a test stub.

---
File: core/config.py
Path: core/config.py
Role: Central configuration and validation for runtime and crypto parameters.
Key symbols: CONFIG dict, validate_config(), _apply_env_overrides()
Inputs: environment variables and built-in defaults; Outputs: validated CONFIG mapping and raises ConfigError on violations.
Observations:
- Comprehensive validation (ports, types, ranges, host IPs, DRONE_PSK checks).
- ENV overrides supported and parsed carefully.
- Defaults enable Ascon tokens and keep many dev-friendly defaults.
Issues/Risks:
- DRONE_PSK default is empty and validation only enforces presence when ENV != 'dev' — risk of accidental insecure deployments if ENV not set correctly.
- Several env-override keys are allowed but raising ConfigError for unsupported key in _apply_env_overrides may crash if new envs are present; this is intentional but must be documented for operators.
- Host validation uses ip_address() rejecting hostnames; some lab setups may expect hostnames.
Severity: Medium (configuration mistakes can lead to insecure deployments)
Suggestions:
- Document requirement to set ENV=production (or similar) and the mandatory DRONE_PSK injection in ops README.
- Consider safer default for ENV handling or explicit production mode flag.

---
File: core/run_proxy.py
Path: core/run_proxy.py
Role: CLI entrypoint and high-level runner for drone/GCS proxies and identity management.
Key symbols: main(), gcs_command(), drone_command(), _build_matrix_secret_loader/_public_loader
Inputs: CLI args, filesystem secrets under `secrets/`, CONFIG; Outputs: starts proxy_runner and persists logs/status JSON.
Observations:
- Robust fallback handling for oqs key import/export API differences.
- Ephemeral key option for development but with clear warnings.
- JSON status writing attempts atomic write using tmp file; handles Windows quirks.
Issues/Risks:
- init_identity uses Signature(suite['sig_name']) then expects export_secret_key()/generate_keypair() — code handles various oqs builds but fallback messaging may confuse operators.
- Danger: public/secret key files are written with minimal permission hardening on Windows (os.chmod best-effort only). On multi-user hosts this could be insufficient.
Severity: Medium
Suggestions:
- Document key file permissions and recommend secure storage/backups.
- Add optional integration with OS keystores or platform-specific guidance for Windows.

---
File: core/handshake.py
Path: core/handshake.py
Role: Implements PQC handshake (server hello, sign/verify, KEM encaps/decap), key derivation, and PSK-based authentication tag for drone->GCS.
Key symbols: build_server_hello(), parse_and_verify_server_hello(), client_encapsulate(), server_decapsulate(), derive_transport_keys(), server_gcs_handshake(), client_drone_handshake()
Inputs: socket streams (TCP), oqs primitives, DRONE_PSK env, suite dict; Outputs: symmetric transport keys, session_id, handshake metrics.
Observations:
- Proper signature verification enforced on drone (parse_and_verify_server_hello) — no bypass paths seen.
- HKDF with SHA-256 used for key derivation, with explicit salt and info strings.
- HMAC tag for drone auth uses DRONE_PSK over server_hello; server checks tag with compare_digest.
- Metrics collection is thorough and defensive.
Issues/Risks:
- DRONE_PSK handling: env var lookup uses "DRONE_PSK" or CONFIG value; if empty in dev, tag becomes all-zero? (server computes expected_tag = hmac.new(_drone_psk_bytes(), hello_wire,...). If psk empty bytes then HMAC over empty key is valid but insecure.) This is acceptable for dev but must be prevented in production.
- Key sizes and type checks enforced but exceptions raised are sometimes generic (RuntimeError) — could be more specific.
- Potential resource cleanup: kem objects and signature objects call .free where available — good but rely on optional oqs API presence.
Severity: High (cryptographic handshake core; PSK misconfiguration can be critical)
Suggestions:
- Enforce non-empty PSK when ENV!=dev and add clear runtime error if PSK is empty in production.
- Add runtime check/logging when empty PSK is detected (in dev) to avoid accidental promotion.

---
File: core/async_proxy.py
Path: core/async_proxy.py
Role: Selector-based UDP proxy bridging plaintext↔encrypted, performing handshakes and in-band rekey control.
Key symbols: run_proxy(), _perform_handshake(), _setup_sockets(), _build_sender_receiver(), ProxyCounters
Inputs: suite, CONFIG, loaded keys, sockets; Outputs: bridged UDP traffic, status files, counters.
Observations:
- Uses deterministic IV construction (epoch||seq) and omits IV on wire to save bytes; receiver reconstructs IV.
- Replay window and sequence anti-replay implemented in Receiver._check_replay with bitmask sliding window.
- Control-plane (0x02) supports two-phase commit with prepare/commit/commit_rekey flows.
- Strict peer/source IP matching and rate-limiting for handshake implemented.
Issues/Risks:
- The optimized omission of IV from wire is OK but requires careful epoch/seq handling; SequenceOverflow and epoch wrap checks exist but operators must monitor rekey thresholds.
- Peer IP strictness (STRICT_HANDSHAKE_IP, STRICT_UDP_PEER_MATCH) default True — safe but may break NAT/testbeds; code warns accordingly.
- Potential DoS risk: token bucket in accept loop has prune logic but unbounded seen dict could grow if many IPs connect; prune exists but ensure values configured.
- A few catch-all excepts may obscure root causes in production logs.
Severity: High (data-plane and replay/auth enforcement central to security/availability)
Suggestions:
- Add operational monitoring/alerts for sequence exhaustion and epoch wrap proximity.
- Consider bounded memory caps/metrics for token-bucket seen map and explicit logging when pruning triggers.

---
File: core/aead.py
Path: core/aead.py
Role: AEAD framing primitives, Sender/Receiver, Ascon adapter, and anti-replay logic.
Key symbols: Sender.encrypt(), Receiver.decrypt(), _instantiate_aead(), _AsconAdapter
Inputs: keys, plaintext/ciphertext, header AAD; Outputs: ciphertext or plaintext and exceptions on failure.
Observations:
- Supports AES-GCM, ChaCha20-Poly1305, and Ascon (native or pyascon). Key size checks enforced.
- Deterministic IV derived from epoch||seq with nonce reconstruction — reduces wire overhead.
- Replay window requires window >= 64 and uses 1<<window mask; correct masking applied.
Issues/Risks:
- Deterministic IVs are safe if never reused; the code prevents wrap-around by forbidding epoch wrap and providing SequenceOverflow, but the enormous default threshold (1<<63) may mask operator-unnoticed long-term reuse risk.
- _AsconAdapter falls back to pyascon or native; if neither present _instantiate_aead raises ImportError — callers must handle.
- HEADER_STRUCT uses a fixed struct format; ensure alignment across platforms.
Severity: High
Suggestions:
- Provide runtime monitoring of `seq` and a safe, operational threshold (e.g., configurable lower default) to prompt rekey well before IV exhaustion.
- Document requirement for Ascon native module for high-performance/MTU use-cases.

---
File: core/policy_engine.py
Path: core/policy_engine.py
Role: In-band control state machine handling prepare/commit/status messages and coordinator logic.
Key symbols: ControlState, request_prepare(), handle_control(), record_rekey_result()
Observations:
- Two-phase commit-style flow implemented with safe guards and seen_rids to avoid replay of control messages.
- Thread-safe with locks and outbox queue for outbound control messages.
Issues/Risks:
- state.seen_rids has maxlen=256; under high churn this may re-accept older rids — acceptable tradeoff but should be documented.
- No signature/authentication on control messages; control-plane is protected by encrypted AEAD and (optionally) ENABLE_PACKET_TYPE — this is OK but worth calling out.
Severity: Medium
Suggestions:
- Consider optional signed control messages or stronger ordering guarantees for noisy networks.

---
File: tools/power_utils.py
Path: tools/power_utils.py
Role: Utilities to parse CSV power traces and integrate energy for analysis.
Key symbols: load_power_trace(), integrate_energy_mj(), PowerSample dataclass
Observations:
- Robust header detection and tolerant parsing of voltage/current vs power columns.
- Trapezoidal integration used for energy calculation.
Issues/Risks: None notable. Handles missing data and sorts chronologically.
Severity: Low
Suggestions: None

---
Progress: Initial traversal and analysis of key modules complete. Next: iterate remaining files (auto/*, core/* extras, secrets, tools, tests), append findings, map flows, and produce final recommendations.


=== Verification Addendum (2025-12-25) ===

Scope: requested Phase 1–4 verification checkpoints across crypto, networking robustness, and efficiency.

Phase 1: Crypto correctness & edge-cases

GREEN
- Handshake transcript binding: length-prefixed transcript hashing and Finished MAC are present (prevents transcript ambiguity).
- Downgrade resistance: client checks negotiated KEM/SIG against expected suite; signature covers key suite identifiers and challenge.
- Nonce/IV safety: deterministic IV construction uses epoch||seq; epoch wrap is forbidden and SequenceOverflow triggers rekey.
- Replay protection: receiver uses sliding replay window and rejects replays.

YELLOW
- Operational safety: default rekey threshold is extremely large (2^63) which is cryptographically fine, but it can hide “never rekeys” operator mistakes. Consider lowering REKEY_SEQ_THRESHOLD operationally for long-lived sessions.
- PSK safety: empty PSK is permitted in dev; make sure ENV discipline prevents accidental production use of empty PSK.

Phase 2: Networking robustness & rekey-grace safety

GREEN
- TCP handshake framing: length-prefixed reads handle partial reads.
- TCP control framing: newline-delimited JSON buffer handles partial reads.
- Socket lifecycle: UDP sockets and selector are closed via context managers/finally.

YELLOW (FIXED)
- Thread safety: background rekey worker updated sockets["encrypted_peer"], while the main loop read it concurrently for sendto(). This is a data race and can cause transient misrouting during rekey.
	Fix: main loop now routes via active_context["peer_addr"] under lock; worker no longer mutates sockets dict.
- Key retention: old_receiver could remain referenced after grace expiry if no mismatched packets arrive (keys linger longer than intended).
	Fix: periodic grace-expiry cleanup runs in the main loop.

Phase 3: Efficiency & boundedness

GREEN
- Power monitor producer/consumer queue is bounded (maxsize) and batches disk writes.

YELLOW (OPTIONAL MITIGATION ADDED)
- If disk I/O stalls, producer blocking on queue can stall sampling and extend capture wall-time.
	Mitigation: POWER_MONITOR_BLOCK_ON_FULL=0 enables drop-on-full behavior to preserve liveness under extreme I/O pressure.

Phase 4: Best-practices alignment (event loop & MAVLink friendliness)

GREEN
- Selector-based UDP proxy loop is appropriate for low-overhead RPi usage; avoids heavyweight frameworks.
- MAVLink friendliness: telemetry/reporting runs out-of-band (status JSON + optional control-plane messages) and does not interfere with MAVLink payload framing.


=== Scheduler/Operations Addendum (2025-12-25) ===

File: sscheduler/sgcs.py
Path: sscheduler/sgcs.py
Role: GCS-side follower; exposes TCP control server and launches the GCS proxy + MAVProxy/QGC integration.
Key symbols: ControlServer, GcsProxyManager, TrafficGenerator
Observations:
- Persistent MAVProxy master listens on GCS plaintext RX port (default 47002) and forwards to the GCS proxy plaintext TX port (default 47001).
- TrafficGenerator previously attempted to bind directly on GCS_HOST:47002; on Windows this commonly collides with MAVProxy’s UDP listener and can silently break traffic generation.
Fix applied:
- TrafficGenerator bind is now best-effort; on bind conflict it continues TX-only (so suites can still run).
- TrafficGenerator TX now targets the local proxy plaintext input (GCS_PLAINTEXT_HOST:47001), ensuring traffic actually exercises the encrypted tunnel.
Severity: Medium (availability/diagnostics; can cause false “no traffic” / misleading results)
Suggestion:
- Keep only one consumer of GCS_PLAINTEXT_RX (47002). If you need both MAVProxy and a synthetic blaster, use separate ports or rely on proxy counters/status JSON.

---
File: sscheduler/sdrone.py
Path: sscheduler/sdrone.py
Role: Drone-side controller; starts drone proxy + persistent MAVProxy and drives suite rotation by commanding the GCS follower.
Key symbols: DroneScheduler, DroneProxyManager, UdpEchoServer
Observations:
- Persistent MAVProxy wiring is loopback-based (masters on 127.0.0.1:DRONE_PLAINTEXT_RX and out to 127.0.0.1:DRONE_PLAINTEXT_TX), consistent with core proxy defaults.
- UdpEchoServer binding previously used DRONE_HOST (LAN IP), which is inconsistent with loopback plaintext defaults.
Fix applied:
- UdpEchoServer now binds/sends using DRONE_PLAINTEXT_BIND / DRONE_PLAINTEXT_HOST where available, falling back to 127.0.0.1.
Severity: Low/Medium (only impacts echo-mode usage; MAVProxy path is primary)

---
File: scripts/run_sscheduler_gcs.ps1
Path: scripts/run_sscheduler_gcs.ps1
Role: Operator helper for Windows; ensures inbound firewall rules exist, then starts sscheduler follower.
Observations:
- Explicitly opens inbound TCP 46000 (handshake), UDP 46011 (encrypted receive on GCS), and TCP 48080 (scheduler control).
Severity: High operational importance on Windows (most common cause of “handshake works but link stays down” is UDP being blocked).

---
File: core/handshake.py
Path: core/handshake.py
Role: PQC handshake + key derivation.
Key change vs 39a4e96 baseline:
- Added a “Finished” explicit key-confirmation exchange derived from HKDF output.
Risk:
- If the GCS and drone are running different commits (one with Finished support, one without), handshake will fail deterministically.
Severity: High (interop)
Suggestion:
- Treat code version parity across Windows+Pi as a hard requirement; pin both to the same commit when debugging connectivity.

