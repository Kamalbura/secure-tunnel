% ============================================================================
%  CHAPTER 1 â€” INTRODUCTION
% ============================================================================
\chapter{Introduction}
\label{ch:introduction}

\epigraph{The best time to worry about security was twenty years ago. The second best time is now.}{---Common saying in cryptographic engineering}

\section{Why This Book Exists}
\label{sec:intro-why}

Imagine you are flying a drone over a field, monitoring crops, inspecting a bridge, or delivering a medical supply package to a remote village. Your drone is in the air, a kilometer away, and you are sitting at a laptop---the \textbf{Ground Control Station (GCS)}---watching its battery level, altitude, GPS coordinates, and camera feed. You can send it commands: ``fly to waypoint 3,'' ``return to launch,'' ``descend to 50 meters.''

All of this communication---the telemetry flowing from the drone to you, and the commands flowing from you to the drone---travels through the air as radio waves. And here is the problem: \emph{anyone with a compatible radio receiver can hear those radio waves.}

Worse, they might not just listen. They might record every packet you send, store it on a hard drive, and wait. Wait for ten years. Wait for twenty. Wait until quantum computers---machines that exploit the strange laws of quantum physics to perform certain calculations exponentially faster than any classical computer---become powerful enough to break the encryption that protects your communication today.

This scenario is not science fiction. It has a name: the \textbf{``store now, decrypt later''} attack. Intelligence agencies, corporate espionage operations, and nation-state adversaries are already collecting encrypted communications, betting that future quantum computers will let them read those messages retroactively.

For consumer drones flying over a park, this may seem like a distant concern. But for military UAVs, critical infrastructure inspection drones, or medical delivery systems, the data transmitted today may still be sensitive in twenty years. The flight patterns reveal surveillance targets. The command protocols reveal operational procedures. The telemetry reveals the capabilities and limitations of the hardware.

This book describes a system built to address this problem: a \textbf{post-quantum secure tunnel} for drone communication. The system takes the standard MAVLink protocol used by most drones in the world and wraps it in a layer of encryption that is designed to resist attacks from both today's classical computers and tomorrow's quantum computers.

\section{The Problem, Precisely Stated}
\label{sec:intro-problem}

Let us state the problem with engineering precision:

\begin{enumerate}
  \item \textbf{MAVLink is unencrypted by default.} The MAVLink protocol~\cite{mavlink-spec}, used by ArduPilot, PX4, and most open-source drone autopilot systems, transmits telemetry and commands as plaintext UDP packets. Anyone on the same network (or within radio range) can read, modify, or inject packets.
  
  \item \textbf{Classical encryption is vulnerable to quantum attack.} Standard approaches like TLS with RSA or ECDHE key exchange rely on the hardness of integer factorization or discrete logarithms. Shor's algorithm~\cite{shor1994}, when executed on a sufficiently large quantum computer, can solve both problems in polynomial time, rendering these schemes useless.
  
  \item \textbf{Drone links have unique constraints.} Unlike web browsers, drones require:
  \begin{itemize}
    \item \textbf{Low latency:} Commands must arrive within milliseconds to maintain stable flight.
    \item \textbf{Tolerance for packet loss:} UDP is used because retransmission delays (as in TCP) are unacceptable for real-time control.
    \item \textbf{Limited compute:} The drone's companion computer (a Raspberry Pi) has far less processing power than a server.
    \item \textbf{Limited energy:} Every millijoule spent on encryption is a millijoule not spent on flying.
    \item \textbf{Key rotation:} Long flights may require periodic rekeying to limit the damage of any single key compromise.
  \end{itemize}
  
  \item \textbf{No off-the-shelf solution fits.} VPNs like WireGuard or IPsec are designed for general-purpose networking. They do not support post-quantum algorithms (at the time of implementation), do not provide per-packet algorithm identification needed for benchmarking, and add unnecessary protocol overhead for a point-to-point link.
\end{enumerate}

Therefore, the system described in this book was built from scratch: a custom, purpose-built, post-quantum secure tunnel for MAVLink traffic.

\section{What the System Does}
\label{sec:intro-what}

At the highest level, the system works like this:

\begin{analogy}
Imagine two people who want to have a private conversation in a crowded room. First, they step into a quiet corner and agree on a secret code (the \textbf{handshake}). Then they return to the crowd and speak in code (the \textbf{encrypted data plane}). If anyone overhears, all they get is gibberish. And the code they used was chosen specifically so that even a quantum-computer-equipped eavesdropper cannot crack it.
\end{analogy}

More technically:

\begin{enumerate}
  \item The GCS starts a \textbf{proxy process} that listens for incoming connections.
  \item The drone starts its own \textbf{proxy process} that connects to the GCS.
  \item They perform a \textbf{TCP handshake} using post-quantum key encapsulation (to establish a shared secret) and post-quantum digital signatures (to authenticate the GCS's identity).
  \item From the shared secret, they derive \textbf{two symmetric keys}: one for drone-to-GCS traffic, one for GCS-to-drone traffic.
  \item All subsequent MAVLink traffic is \textbf{encrypted and authenticated} using an AEAD cipher (AES-256-GCM, ChaCha20-Poly1305, or ASCON-128a) with the derived keys.
  \item The proxies sit transparently between the applications and the network. MAVProxy and Mission Planner do not know the tunnel exists---they send and receive plaintext MAVLink as usual.
\end{enumerate}

The system supports over 70 different \textbf{cipher suites}---combinations of key encapsulation, signature, and encryption algorithms---allowing comprehensive benchmarking of different post-quantum approaches on real hardware.

% -- System Overview Diagram --
\begin{figure}[htbp]
\centering
\begin{tikzpicture}[
  block/.style={draw, rounded corners=4pt, minimum width=3.2cm, minimum height=1cm,
                font=\small, align=center, fill=#1},
  arr/.style={-{Stealth[length=2.5mm]}, thick},
  darr/.style={{Stealth[length=2.5mm]}-{Stealth[length=2.5mm]}, thick},
]
  % Drone side
  \node[block=blue!10] (fc) at (0, 0) {Pixhawk FC\\ArduPilot};
  \node[block=blue!15] (mavd) at (0, 2) {MAVProxy\\(Drone)};
  \node[block=orange!20] (proxyd) at (0, 4) {PQC Proxy\\(Drone Side)};

  % Network
  \node[block=red!10, minimum width=4cm] (net) at (5, 4) {WiFi LAN\\Encrypted UDP};

  % GCS side
  \node[block=orange!20] (proxyg) at (10, 4) {PQC Proxy\\(GCS Side)};
  \node[block=green!15] (mavg) at (10, 2) {MAVProxy\\(GCS)};
  \node[block=green!10] (mp) at (10, 0) {Mission Planner\\QGroundControl};

  % Arrows
  \draw[darr, blue] (fc) -- node[right, font=\tiny] {USB serial} (mavd);
  \draw[darr, blue] (mavd) -- node[right, font=\tiny, align=center] {plaintext UDP\\(localhost)} (proxyd);
  \draw[darr, red] (proxyd) -- node[above, font=\tiny] {PQC-encrypted} (net);
  \draw[darr, red] (net) -- node[above, font=\tiny] {PQC-encrypted} (proxyg);
  \draw[darr, blue] (proxyg) -- node[right, font=\tiny, align=center] {plaintext UDP\\(localhost)} (mavg);
  \draw[darr, blue] (mavg) -- node[right, font=\tiny] {localhost} (mp);

  % Labels
  \node[font=\footnotesize\bfseries, above=0.2cm of proxyd] {Drone (RPi)};
  \node[font=\footnotesize\bfseries, above=0.2cm of proxyg] {GCS (Windows)};

  % Power sensor
  \node[block=yellow!20, minimum width=1.8cm, minimum height=0.6cm] (ina) at (-3, 1) {\tiny INA219\\Power};
  \draw[arr, dashed, gray] (ina) -- (proxyd);
\end{tikzpicture}
\caption{System overview: the PQC proxy sits transparently between applications and the network.  All traffic crossing the WiFi link is post-quantum encrypted.}
\label{fig:system-overview}
\end{figure}

\section{The Hardware}
\label{sec:intro-hardware}

This is not a simulation. The system runs on real hardware:

\begin{description}
  \item[Drone side:] A Raspberry Pi (ARM-based single-board computer) connected to a Pixhawk flight controller via USB serial. The Pixhawk runs ArduPilot firmware and controls the physical drone. The Raspberry Pi runs the secure tunnel proxy, MAVProxy, and metrics collection.
  
  \item[GCS side:] A Windows laptop running Mission Planner or QGroundControl for flight control visualization, plus the secure tunnel proxy and benchmark orchestration software.
  
  \item[Network:] Both devices are connected via a WiFi LAN (local area network). The encrypted traffic traverses the WiFi link; plaintext traffic stays on localhost (127.0.0.1).
  
  \item[Power measurement:] An INA219 current sensor on the I2C bus of the Raspberry Pi measures real-time voltage, current, and power consumption at 1\,kHz sampling rate.
\end{description}

\section{The Software Stack}
\label{sec:intro-software}

The codebase is written primarily in Python and is organized into three major layers:

\begin{description}
  \item[\filename{core/}] The tunnel engine. This contains the handshake protocol, AEAD encryption/decryption, the UDP proxy, the suite registry, configuration management, metrics collection, power monitoring, and all cryptographic logic. This is the most security-critical code.
  
  \item[\filename{sscheduler/}] The orchestration layer. This contains the benchmark scheduler that cycles through all cipher suites, manages proxy processes on both drone and GCS, collects metrics, and saves results. The drone acts as the controller; the GCS is a follower that responds to commands.
  
  \item[\filename{dashboard/}] The analytics layer. A FastAPI backend loads benchmark results from JSON files, computes derived metrics, and serves them via a REST API. A React/TypeScript frontend visualizes the data with interactive charts, tables, and comparison tools.
\end{description}

The cryptographic primitives are provided by \textbf{liboqs} (Open Quantum Safe)~\cite{liboqs}, a C library that implements all NIST-standardized and candidate post-quantum algorithms. The system accesses liboqs through its Python bindings (\texttt{oqs-python}).

\section{The Scope of This Book}
\label{sec:intro-scope}

This book explains the \emph{entire} system---from the theoretical
foundations of post-quantum cryptography through every line of
implementation code to the deployment procedures and benchmark results.
Table~\ref{tab:chapter-map} provides a chapter-by-chapter map.

\begin{longtable}{c l p{7cm}}
  \caption{Chapter map and reading guide.}
  \label{tab:chapter-map} \\
  \toprule
  \textbf{Ch.} & \textbf{Title} & \textbf{What You Will Learn} \\
  \midrule
  \endfirsthead
  \bottomrule
  \endfoot

  1  & Introduction        & Motivation, system overview, hardware/software \\
  2  & Networking           & TCP/IP, UDP, sockets, NAT, mDNS \\
  3  & Cryptography         & Symmetric/asymmetric, AEAD, key exchange, signatures \\
  4  & Post-Quantum         & Lattices, codes, hashes; NIST standards \\
  5  & MAVLink              & Drone protocol, packet format, security gaps \\
  6  & Architecture         & System design, data flow, component interactions \\
  7  & Handshake            & 2-message PQC authenticated key exchange \\
  8  & AEAD Framing         & Wire format, replay protection, epoch management \\
  9  & Proxy Engine         & Selectors loop, socket architecture, rekey integration \\
  10 & Suite Registry       & KEM$\times$SIG$\times$AEAD composition, alias resolution \\
  11 & Scheduler            & Drone-controlled cycling, GCS follower, MAVProxy mode \\
  12 & Metrics              & 18-category schema, collectors, aggregation \\
  13 & Dashboard            & FastAPI backend, React frontend, visualization \\
  14 & Engineering          & Cross-platform, error handling, lessons learned \\
  15 & Conclusion           & Contributions, findings, future work \\
  16 & Dependencies         & Every package, its role, version constraints \\
  17 & Codebase Walkthrough & Module-by-module tour of all 97 Python files \\
  18 & Testing              & 18 test files, patterns, how to run the suite \\
  19 & Benchmarks           & 19{,}600 measurements, KEM/SIG/AEAD/power results \\
  20 & Deployment           & Step-by-step setup, launch, and troubleshooting \\
  A  & Configuration Keys   & Complete CONFIG dictionary reference \\
  B  & Wire Protocol        & Byte-level wire format specification \\
  C  & Metrics Schema       & All 231 metric fields across 18 categories \\
\end{longtable}
\section{A Word About Reading Order}
\label{sec:intro-reading-order}

If you are a student encountering these topics for the first time, read the book sequentially. Each chapter builds on the previous one.

If you are an engineer who already understands networking and cryptography, you may skip to Part~II (Chapter~\ref{ch:mavlink}) and refer back to the Glossary and foundational chapters as needed.

If you are a researcher interested specifically in the post-quantum performance measurements, jump directly to Chapter~\ref{ch:benchmarks} for the benchmark results, then read Chapters~\ref{ch:metrics} and~\ref{ch:dashboard} for context on how the data was collected and visualised.

If you are deploying the system, start with Chapter~\ref{ch:deployment} for the step-by-step setup guide, then read Chapter~\ref{ch:dependencies} for the complete software dependency map.

Let us begin.
