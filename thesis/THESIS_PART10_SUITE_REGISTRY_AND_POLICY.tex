% Part 10 â€” Suite Registry and Scheduling Policy
\section{Suite Registry and Scheduling Policy}
\label{sec:suite-registry-policy}

\subsection{Scope and Terminology}
This part describes how cryptographic suites are registered and how scheduling policies select suites at runtime. Key terms are:
\begin{itemize}
	\item \textbf{Suite registry}: The canonical mapping of suite IDs to KEM/AEAD/SIG metadata in \texttt{core/suites.py}.
	\item \textbf{Suite ID}: The canonical identifier of the form \texttt{cs-<kem>-<aead>-<sig>}.
	\item \textbf{Benchmark policy}: A deterministic, exhaustive policy that cycles through suites for measurement.
	\item \textbf{Telemetry-aware policy}: A safety-oriented policy that upgrades/downgrades suites based on telemetry and hysteresis.
\end{itemize}
\footnote{Evidence: core/suites.py; sscheduler/benchmark\_policy.py; sscheduler/policy.py.}

\subsection{Registry Structure: KEM, Signature, and AEAD Catalogs}
The suite registry is composed of three primary catalogs: KEMs, signatures, and AEADs. Each entry includes a token, OQS or display name, NIST level, embedded identifier fields (e.g., \texttt{kem\_id}, \texttt{sig\_id}), and a list of aliases. The registry explicitly maps ML-DSA-44 to NIST L1 for practical pairing with L1 KEMs.
\footnote{Evidence: core/suites.py (\texttt{\_KEM\_REGISTRY}, \texttt{\_SIG\_REGISTRY}, \texttt{\_AEAD\_REGISTRY}, module docstring notes).}

\subsection{Alias Normalization and Suite ID Construction}
Alias normalization removes punctuation and casing to resolve tokens consistently. \texttt{build\_suite\_id()} resolves aliases for KEM, AEAD, and signature names and constructs the canonical suite ID. A fixed suite alias table maps legacy Kyber/Dilithium and SPHINCS+ naming conventions into the canonical ML-KEM/ML-DSA suite identifiers.
\footnote{Evidence: core/suites.py (\texttt{\_normalize\_alias()}, \texttt{\_build\_alias\_map()}, \texttt{build\_suite\_id()}, \texttt{\_SUITE\_ALIASES}).}

\subsection{Level-Consistent Suite Matrix Generation}
Suites are generated by pairing KEM and signature entries that share the same NIST security level. The registry produces a deterministic matrix sorted by KEM and signature token, then expands across a fixed AEAD order. Environment variables can exclude specific KEMs or AEADs from suite generation without removing them from the registry.
\footnote{Evidence: core/suites.py (\texttt{\_generate\_level\_consistent\_matrix()}, \texttt{\_AEAD\_ORDER}, \texttt{\_generate\_suite\_registry()}).}

\subsection{Runtime AEAD Availability and Suite Pruning}
AEAD availability is probed at runtime. AES-GCM is always included; ChaCha20-Poly1305 and Ascon-128a are optional based on installed dependencies and configuration flags. Ascon support is detected via a native module or the pure-Python fallback. A runtime pruning step removes suites whose signatures are not supported by the current OQS environment.
\footnote{Evidence: core/suites.py (\texttt{\_probe\_aead\_support()}, \texttt{available\_aead\_tokens()}, \texttt{unavailable\_aead\_reasons()}, \texttt{\_prune\_suites\_for\_runtime()}).}

\subsection{Suite Accessors and Header ID Embedding}
The registry exposes \texttt{list\_suites()} and \texttt{get\_suite()} to retrieve immutable suite configurations, resolving aliases and validating required fields. The helper \texttt{header\_ids\_for\_suite()} returns embedded identifier tuples and \texttt{header\_ids\_from\_names()} resolves IDs from algorithm names for runtime header validation. Suite IDs are also serialized into bytes for HKDF info via \texttt{suite\_bytes\_for\_hkdf()}.
\footnote{Evidence: core/suites.py (\texttt{list\_suites()}, \texttt{get\_suite()}, \texttt{header\_ids\_for\_suite()}, \texttt{header\_ids\_from\_names()}, \texttt{suite\_bytes\_for\_hkdf()}).}

\subsection{Benchmark Policy: Deterministic Exhaustive Coverage}
The benchmark policy in \texttt{sscheduler/benchmark\_policy.py} loads \texttt{settings.json} and reads the \texttt{benchmark\_mode} section to configure cycling intervals and output directories. It constructs an ordered suite list, optionally filtering by AEAD token, and sorts suites by NIST level, KEM, and signature for organized reporting. It maintains a run ID, per-suite iteration metrics, and writes results to \texttt{logs/benchmarks}.
\footnote{Evidence: sscheduler/benchmark\_policy.py (\texttt{load\_benchmark\_settings()}, \texttt{BenchmarkPolicy.\textunderscore\textunderscore init\textunderscore\textunderscore()}, \texttt{\_build\_suite\_list()}, \texttt{SuiteMetrics})).}

\subsection{Benchmark Metrics Capture Hooks}
The benchmark policy includes a \texttt{SuiteMetrics} record that stores handshake, throughput, latency, and power metrics alongside cryptographic primitive timings and artifact sizes. Handshake metrics are populated from proxy handshake timing structures, and suite metadata (KEM, signature, AEAD, NIST level) is captured at suite start.
\footnote{Evidence: sscheduler/benchmark\_policy.py (\texttt{SuiteMetrics}, \texttt{\_start\_suite\_metrics()}, \texttt{record\_handshake\_metrics()}).}

\subsection{Telemetry-Aware Policy: Settings and Filtering}
The telemetry-aware policy \texttt{TelemetryAwarePolicyV2} loads thresholds and limits from \texttt{settings.json}. It filters the suite list by allowed AEAD and maximum NIST level, then sorts suites by a deterministic tier function that combines NIST level and AEAD/KEM sub-tiers.
\footnote{Evidence: sscheduler/policy.py (\texttt{load\_settings()}, \texttt{TelemetryAwarePolicyV2.\textunderscore\textunderscore init\textunderscore\textunderscore()}, \texttt{\_filter\_suites()}, \texttt{get\_suite\_tier()}); settings.json.}

\subsection{Telemetry-Aware Decision Logic}
The policy evaluates a \texttt{DecisionInput} snapshot and applies a structured sequence: telemetry freshness gate, emergency downgrade on critical battery/thermal thresholds, rollback on blackouts shortly after a switch, cooldown gating, downgrade on sustained link degradation, downgrade on sustained thermal/battery stress, optional rekey when stable and within rate limits, and conservative upgrade only when disarmed and stable. The output encodes action, target suite, and reasons.
\footnote{Evidence: sscheduler/policy.py (\texttt{DecisionInput}, \texttt{PolicyOutput}, \texttt{TelemetryAwarePolicyV2.evaluate()}).}

\subsection{Blacklist, Hysteresis, and Rekey Rate Limits}
The policy maintains a blacklist with TTL to avoid oscillations after failure, uses per-condition hysteresis timers for downgrade and upgrade decisions, and records successful rekeys in a sliding window to enforce rekey rate limits. The rekey timestamp list is updated only after successful rekey execution.
\footnote{Evidence: sscheduler/policy.py (\texttt{\_add\_blacklist()}, \texttt{\_check\_hysteresis()}, \texttt{record\_rekey()} and rekey window logic).}

\subsection{Simple Scheduler Policies}
In addition to the telemetry-aware policy, the scheduler defines simpler suite selection policies: \texttt{LinearLoopPolicy} for round-robin sequencing, \texttt{RandomPolicy} for stochastic selection, and \texttt{ManualOverridePolicy} to allow explicit suite pinning with a linear fallback. These policies implement minimal \texttt{next\_suite()} and duration accessors.
\footnote{Evidence: sscheduler/policy.py (\texttt{LinearLoopPolicy}, \texttt{RandomPolicy}, \texttt{ManualOverridePolicy}).}
